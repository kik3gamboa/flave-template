"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var dictonary_1 = require("./dictonary");
function Tokenizer(input) {
    var tokens = [];
    var charidx = 0;
    input = input
        .replace(/[\r\n]+/gm, "\n")
        .replace(/(\n[\s\n]*\n)/gm, '\n');
    while (getToken()) { }
    return new Tokens(tokens);
    function getToken() {
        if (charidx < input.length) {
            var chunk = '';
            var tokens = dictonary_1.Delimiters[input[charidx]];
            if (!tokens) {
                do {
                    chunk += input[charidx];
                    charidx++;
                    if (charidx >= input.length)
                        break;
                } while (!dictonary_1.Delimiters[input[charidx]]);
            }
            else {
                do {
                    chunk += input[charidx];
                    charidx++;
                    if (charidx >= input.length)
                        break;
                    tokens = tokens.filter(function (t) { return t.substr(0, chunk.length + 1) == (chunk + input[charidx]); });
                } while (tokens.length);
            }
            push(chunk);
            return true;
        }
        return false;
    }
    function push(chunk) {
        if (chunk === '')
            return;
        tokens.push({
            Value: chunk,
            Info: dictonary_1.Symbols[chunk] || { Type: 'LITERAL', Name: 'LITERAL' }
        });
    }
}
exports.Tokenizer = Tokenizer;
var Tokens = /** @class */ (function () {
    function Tokens(tokens) {
        this.index = -1;
        this.line = 1;
        this.tokens = tokens;
    }
    Tokens.getString = function (ary) {
        var str = '';
        if (typeof ary == 'string')
            str = ary;
        else if (ary.length && typeof ary[0] == 'string')
            str = ary.join('\n');
        else if (ary.length && ary[0].hasOwnProperty('Value'))
            str = ary.reduce(function (a, c) { return a += c.Value; }, '');
        return str.split('\n');
    };
    Tokens.prototype.depleted = function () {
        return this.index + 1 >= this.tokens.length;
    };
    Tokens.prototype.next = function () {
        if (this.index + 1 < this.tokens.length) {
            this.index++;
            if (this.current().Info.Name == 'WHITESPACE_NEWLINE')
                this.line++;
            return true;
        }
        return false;
    };
    Tokens.prototype.prev = function () {
        if (this.index > 0) {
            this.index--;
            if (this.current().Info.Name == 'WHITESPACE_NEWLINE')
                this.line--;
            return true;
        }
        return false;
    };
    Tokens.prototype.current = function () {
        return this.tokens[this.index];
    };
    Tokens.prototype.skip = function (continueOn, breakOn, escape) {
        var skipped = [];
        if (!(continueOn || breakOn))
            continueOn = {
                Type: 'WHITESPACE'
            };
        continueOn = continueOn || {};
        breakOn = breakOn || {};
        var nonwhitespace = '';
        for (var i = this.index; i >= 0; i--) {
            if (this.tokens[i].Info.Type != 'WHITESPACE') {
                nonwhitespace = this.tokens[i].Value;
                break;
            }
        }
        while (this.next()) {
            var cur = this.current();
            if (!cur)
                break;
            if (escape && cur.Info.Name == 'ESCAPE') {
                if (!this.next() || this.current().Info.Name == 'WHITESPACE_NEWLINE')
                    this.prev();
                cur = this.current();
            }
            else if (shouldBreak(cur.Info))
                break;
            skipped.push(cur);
            if (cur.Info.Type != 'WHITESPACE') {
                nonwhitespace = cur.Value;
            }
        }
        function shouldBreak(current) {
            for (var key in current) {
                if (breakOn[key] && breakOn[key].indexOf(current[key]) > -1) {
                    if (current.Name == 'REGEX' && breakOn.Name.indexOf('REGEX_OPEN') > -1 && '(,=:[!&|?{};'.indexOf(nonwhitespace.slice(-1)) < 0)
                        return false;
                    return true;
                }
                else if (continueOn[key] && continueOn[key].indexOf(current[key]) > -1)
                    return false;
            }
            return !(Object.keys(breakOn).length);
        }
        return skipped;
    };
    return Tokens;
}());
exports.Tokens = Tokens;
